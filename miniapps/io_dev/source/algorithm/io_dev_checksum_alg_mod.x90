!-----------------------------------------------------------------------------
! (C) Crown copyright 2020 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief Write io_dev checksums to file for testing.
module io_dev_checksum_alg_mod

  implicit none

  private
  public :: io_dev_checksum_alg

contains

  !> @brief Computes the checksum for each field in a field collection &
  !>        writes each checksum to an output file.
  !> @param[in] state Field collection to be checked
  subroutine io_dev_checksum_alg(state)

    use field_mod,              only: field_type
    use field_parent_mod,       only: field_parent_type
    use field_collection_mod,   only: field_collection_type, &
                                      field_collection_iterator_type
    use constants_mod,          only: i_def, r_def, str_max_filename
    use mpi_mod,                only: get_comm_rank
    use log_mod,                only: log_event,         &
                                      LOG_LEVEL_INFO,    &
                                      LOG_LEVEL_ERROR
    implicit none

    type(field_collection_type), intent(in) :: state

    type(field_collection_iterator_type) :: iter
    character(len=str_max_filename)      :: fname
    real(r_def), allocatable             :: checksum_bundle(:)
    real(r_def)                          :: tmp_checksum
    integer(i_def)                       :: stat, iter_index, file_unit

    class(field_parent_type), pointer :: fld => null()
    type(field_type), pointer :: fld_actual => null()

    allocate( checksum_bundle( state%get_length() ) )

    ! Loop through fields and generate checksums
    iter = state%get_iterator()
    iter_index = 0
    do
      if ( .not.iter%has_next() ) exit
      fld => iter%next()
      iter_index = iter_index + 1
      select type(fld)
        type is (field_type)
          ! PSyclone needs to know the actual rather than abstract type
          fld_actual => fld
          call invoke( X_innerproduct_X(tmp_checksum, fld_actual) )
          checksum_bundle(iter_index) = tmp_checksum

      end select
    end do

    file_unit = 9

    ! Open checksum output file
    if ( get_comm_rank() == 0 ) then
      write(fname,'(A,A)') 'io_dev-checksums.txt'
      open( file_unit, file=fname, status="replace", iostat=stat)

      if (stat /= 0) then
        call log_event( "Unable to open checksum file", LOG_LEVEL_ERROR )
      end if

      call log_event( "io_dev: Writing checksum output", LOG_LEVEL_INFO )

      ! Loop through fields and write checksums to file
      iter = state%get_iterator()
      iter_index = 0
      do
        if ( .not.iter%has_next() ) exit
        fld => iter%next()
        iter_index = iter_index + 1
        select type(fld)
          type is (field_type)

          write( file_unit, '(A,A,A,Z16)' ) 'Inner product checksum ', &
                         trim(fld%get_name()),' = ',checksum_bundle(iter_index)

        end select
      end do

      ! Close output file
      close( file_unit )

    end if

    nullify(fld)
    deallocate(checksum_bundle)

  end subroutine io_dev_checksum_alg

end module io_dev_checksum_alg_mod
