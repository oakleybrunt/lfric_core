!-------------------------------------------------------------------------------
! (c) The copyright relating to this work is owned jointly by the Crown, 
! Met Office and NERC 2014. 
! However, it has been created with the help of the GungHo Consortium, 
! whose members are identified at https://puma.nerc.ac.uk/trac/GungHo/wiki
!-------------------------------------------------------------------------------
!
!-------------------------------------------------------------------------------
module gp_vector_rhs_kernel_mod_test
  implicit none 

contains

  @test
  subroutine gp_vector_rhs_kernel_test()
    use pFUnit_Mod
    use gp_vector_rhs_kernel_mod, only : gp_vector_rhs_code
    use gaussian_quadrature_mod,  only : gaussian_quadrature_type, ngp_h, ngp_v, GQ3
    use constants_mod,            only : r_def
    implicit none

    integer :: num_layers, ndf, map(1), undf
    type(gaussian_quadrature_type) :: gq
    real(kind=r_def) :: f_data(1), rhs1(8), rhs2(8), rhs3(8)
    real(kind=r_def) :: answer, tol
    real(kind=r_def), allocatable :: basis(:,:,:,:), &
                                     basis_f(:,:,:,:), &
                                     diff_basis(:,:,:,:)
    real(kind=r_def), allocatable :: xgp_h(:,:), xgp_v(:)
    integer :: ndf_w0, map_w0(8), ndf_f, map_f(1)
    real(kind=r_def) :: chi(8,3)
    real(kind=r_def) :: x_vert(8,3)
    real(kind=r_def) :: fx, fy, fz, dx, dy, dz, t_vec(3)
    integer :: df, dim, gp1, gp2
    
    gq=gq%get_instance(GQ3)

    allocate(xgp_h(ngp_h,2), xgp_v(ngp_v) )

    xgp_h = gq%get_xgp_h()
    xgp_v = gq%get_xgp_v()
    
    x_vert(1,:) = (/ 0.0_r_def, 0.0_r_def, 0.0_r_def /)
    x_vert(2,:) = (/ 1.0_r_def, 0.0_r_def, 0.0_r_def /)
    x_vert(3,:) = (/ 1.0_r_def, 1.0_r_def, 0.0_r_def /)
    x_vert(4,:) = (/ 0.0_r_def, 1.0_r_def, 0.0_r_def /)
    x_vert(5,:) = (/ 0.0_r_def, 0.0_r_def, 1.0_r_def /)
    x_vert(6,:) = (/ 1.0_r_def, 0.0_r_def, 1.0_r_def /)
    x_vert(7,:) = (/ 1.0_r_def, 1.0_r_def, 1.0_r_def /)
    x_vert(8,:) = (/ 0.0_r_def, 1.0_r_def, 1.0_r_def /)    
    
    ndf_w0 = 8
    ndf_f = 1
    allocate( basis_f   (3,ndf_f,ngp_h,ngp_v), &
              basis     (1,ndf_w0,ngp_h,ngp_v), &
	      diff_basis(3,ndf_w0,ngp_h,ngp_v) )

    do df = 1,ndf_w0
      map_w0(df) = df
      do gp2 = 1,ngp_v
        do gp1 = 1,ngp_h
          fx = (1.0_r_def - x_vert(df,1)) + (-1.0_r_def)**(int(x_vert(df,1))+1)*xgp_h(gp1,1)
          fy = (1.0_r_def - x_vert(df,2)) + (-1.0_r_def)**(int(x_vert(df,2))+1)*xgp_h(gp1,2)
          fz = (1.0_r_def - x_vert(df,3)) + (-1.0_r_def)**(int(x_vert(df,3))+1)*xgp_v(gp2)
          diff_basis(1,df,gp1,gp2) = fy*fz
          diff_basis(2,df,gp1,gp2) = fx*fz
          diff_basis(3,df,gp1,gp2) = fx*fy
          basis(1,df,gp1,gp2) = fx*fy*fz
        end do
      end do
      do dim = 1,3
        if ( x_vert(df,dim) < 1.0_r_def ) &
          diff_basis(dim,df,:,:) = -diff_basis(dim,df,:,:)     
      end do
    end do
    chi(:,:) = x_vert(:,:)

    map_f(1) = 1
    t_vec = (/ 1.0_r_def, 2.0_r_def, -1.0_r_def /)
    basis_f(1,:,:,:) = t_vec(1)
    basis_f(2,:,:,:) = t_vec(2)
    basis_f(3,:,:,:) = t_vec(3)
    f_data(1) = 5.0_r_def

    num_layers=1
    rhs1(:) = 0.0_r_def
    rhs2(:) = 0.0_r_def
    rhs3(:) = 0.0_r_def

    call gp_vector_rhs_code(num_layers, &
                            ndf_w0, map_w0, basis, rhs1, rhs2, rhs3, gq, &
                            ndf_f, map_f, basis_f, f_data, &
                            ndf_w0, map_w0, basis, diff_basis, chi(:,1), chi(:,2), chi(:,3))

    dx = 6000.0_r_def
    dy = 1000.0_r_def
    dz = 2000.0_r_def
    answer = 0.125_r_def*f_data(1)

    tol    = 1.0e-2_r_def
    do df = 1, ndf_w0
      @assertEqual(answer*dx*t_vec(1), rhs1(df), tol)
      @assertEqual(answer*dy*t_vec(2), rhs2(df), tol)
      @assertEqual(answer*dz*t_vec(3), rhs3(df), tol)
    end do

  end subroutine gp_vector_rhs_kernel_test

end module gp_vector_rhs_kernel_mod_test
