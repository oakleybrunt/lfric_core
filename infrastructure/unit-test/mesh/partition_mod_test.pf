!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

!> Test the partition module
!>
module partition_mod_test

  use constants_mod,              only: r_def, i_def, i_native, str_max_filename, &
                                        str_def
  use global_mesh_mod,            only: global_mesh_type
  use global_mesh_collection_mod, only: global_mesh_collection_type, &
                                        global_mesh_collection
  use mpi_mod,                    only: store_comm, clear_comm, get_comm_size, get_comm_rank
  use partition_mod,              only: partition_type,                 &
                                        partitioner_planar,             &
                                        partitioner_cubedsphere_serial, &
                                        partitioner_interface
  use pFUnit_Mod
  use reference_element_mod,      only: reference_cube_type
  use yaxt, only : xt_initialize, xt_finalize

  implicit none

  private
  public :: setUp, tearDown, &
            test_partition_CubedSphere, test_partition_BiPeriodic, &
            test_partition_planar, test_partition_trench_x,        &
            test_partition_trench_y

  @testCase
  type, public, extends( MPITestCase ) :: partition_test_type
    private
    integer :: dummy ! This is here only so procedures which do not use "this"
                     ! have something they can hit.
    integer, allocatable :: dummy_for_gfortran
    type(reference_cube_type), pointer :: reference_element => null()
    integer :: total_ranks
    integer :: local_rank
  contains
    procedure :: setUp
    procedure :: tearDown
    procedure :: test_partition_Cubedsphere
    procedure :: test_partition_BiPeriodic
    procedure :: test_partition_planar
    procedure :: test_partition_trench_x
    procedure :: test_partition_trench_y
  end type partition_test_type

  character(str_def), parameter :: mesh_name = 'unit_test'

contains

  subroutine setUp( this )

    implicit none

    class( partition_test_type ), intent( inout ) :: this

    allocate( this%reference_element, source=reference_cube_type() )

    global_mesh_collection = global_mesh_collection_type()

    ! Initialise YAXT
    call xt_initialize(this%getMpiCommunicator())
    !Store the MPI communicator for later use
    call store_comm(this%getMpiCommunicator())

    this%total_ranks = get_comm_size()
    this%local_rank  = get_comm_rank()

  end subroutine setUp

  subroutine tearDown( this )

    implicit none

    class( partition_test_type ), intent( inout ) :: this

    deallocate( this%reference_element )

    call global_mesh_collection%clear()

    ! Finalise YAXT
    call xt_finalize()
    ! Clear the stored MPI communicator
    call clear_comm()

  end subroutine teardown

  !> Test partition module functionality
  !>
  @Test(npes=[1, 4] )
  subroutine test_partition_BiPeriodic( this )

    implicit none

    class( partition_test_type ), intent( inout ) :: this

    type(global_mesh_type), pointer :: global_mesh => null()
    type(partition_type)            :: partition

    procedure (partitioner_interface), pointer :: partitioner_ptr => null()

    integer :: xproc
    integer :: yproc
    integer :: local_rank
    integer :: total_ranks
    integer :: max_stencil_depth

    integer :: num_cells_in_layer
    integer :: inner_depth
    integer :: halo_depth
    integer :: num_cells_inner
    integer :: last_inner_cell
    integer :: num_cells_edge
    integer :: last_edge_cell
    integer :: num_cells_halo
    integer :: last_halo_cell
    integer(i_def) :: num_cells_ghost
    integer :: cell_owner
    integer :: lid
    integer :: gid

    integer(i_def) :: npanels
    integer(i_def) :: global_mesh_id
    integer(i_native) :: num_processes

    character(len = str_max_filename) :: filename

    num_processes = this%context%getNumProcesses()
    select case (num_processes)
      case (1)
        xproc = 1
        yproc = 1
      case (4)
        xproc = 2
        yproc = 2
    end select

    local_rank = this%local_rank
    total_ranks = this%total_ranks
    max_stencil_depth = 1

    filename = 'data/mesh_BiP8x8-6000x2000.nc'
    npanels  = 1
    global_mesh_id =  global_mesh_collection%add_new_global_mesh( filename,  &
                                                                  mesh_name, &
                                                                  npanels )
    global_mesh    => global_mesh_collection%get_global_mesh( global_mesh_id )

    partitioner_ptr => partitioner_planar
    !
    ! Generate the partition
    partition = partition_type( global_mesh, &
                                partitioner_ptr, &
                                xproc, &
                                yproc, &
                                max_stencil_depth, &
                                local_rank, &
                                total_ranks )

    ! Test functionality of the partition object we've just created on both 1
    ! and 4 processes
    select case (num_processes)

      case (1)
        num_cells_in_layer = partition%get_num_cells_in_layer()
        @assertEqual( 64, num_cells_in_layer )

        inner_depth = partition%get_inner_depth()
        @assertEqual( 2, inner_depth )

        num_cells_inner = partition%get_num_cells_inner(1)
        @assertEqual( 20, num_cells_inner )

        last_inner_cell = partition%get_last_inner_cell(1)
        @assertEqual( 36, last_inner_cell )

        num_cells_edge = partition%get_num_cells_edge()
        @assertEqual( 28, num_cells_edge )

        last_edge_cell = partition%get_last_edge_cell()
        @assertEqual( 64, last_edge_cell )

        halo_depth = partition%get_halo_depth()
        @assertEqual( 2, halo_depth )

        num_cells_halo = partition%get_num_cells_halo(1)
        @assertEqual( 0, num_cells_halo )

        last_halo_cell = partition%get_last_halo_cell(1)
        @assertEqual( 64, last_halo_cell )

        num_cells_ghost = partition%get_num_cells_ghost()
        @assertEqual( 0, num_cells_ghost )

        cell_owner = partition%get_cell_owner( 1 )
        @assertEqual( 0, cell_owner )

        lid = 1
        gid = partition%get_gid_from_lid( lid )
        @assertEqual( 27, gid )

        gid = 30
        lid = partition%get_lid_from_gid( gid )
        @assertEqual( 4, lid )

      case (4)
        num_cells_in_layer = partition%get_num_cells_in_layer()
        @assertEqual( 64, num_cells_in_layer )

        inner_depth = partition%get_inner_depth()
        @assertEqual( 2, inner_depth )

        num_cells_inner = partition%get_num_cells_inner(1)
        @assertEqual( 4, num_cells_inner )

        last_inner_cell = partition%get_last_inner_cell(1)
        @assertEqual( 4, last_inner_cell )

        num_cells_edge = partition%get_num_cells_edge()
        @assertEqual( 12, num_cells_edge )

        last_edge_cell = partition%get_last_edge_cell()
        @assertEqual( 16, last_edge_cell )

        halo_depth = partition%get_halo_depth()
        @assertEqual( 2, halo_depth )

        num_cells_halo = partition%get_num_cells_halo(1)
        @assertEqual( 20, num_cells_halo )

        last_halo_cell = partition%get_last_halo_cell(1)
        @assertEqual( 36, last_halo_cell )

        num_cells_ghost = partition%get_num_cells_ghost()
        @assertEqual( 0, num_cells_ghost )

        cell_owner = partition%get_cell_owner(1)
        @assertEqual( local_rank, cell_owner )

        lid = 1
        gid = partition%get_gid_from_lid( lid )
        select case (local_rank)
          case (0)
            @assertEqual( 50, gid )
          case (1)
            @assertEqual( 54, gid )
          case (2)
            @assertEqual( 18, gid )
          case (3)
            @assertEqual( 22, gid )
        end select

        gid = 30
        lid = partition%get_lid_from_gid( gid )
        select case (local_rank)
          case (0)
            @assertEqual( 54, lid )
          case (1)
            @assertEqual( 54, lid )
          case (2)
            @assertEqual( 43, lid )
          case (3)
            @assertEqual( 3, lid )
        end select

    end select

  end subroutine test_partition_BiPeriodic

  @Test(npes=[1, 4] )
  subroutine test_partition_planar( this )

    implicit none

    class( partition_test_type ), intent( inout ) :: this

    type(global_mesh_type), pointer :: global_mesh => null()
    type(partition_type)            :: partition

    procedure (partitioner_interface), pointer :: partitioner_ptr => null()

    integer :: xproc
    integer :: yproc
    integer :: local_rank
    integer :: total_ranks
    integer :: max_stencil_depth

    integer :: num_cells_in_layer
    integer :: inner_depth
    integer :: halo_depth
    integer :: num_cells_inner
    integer :: last_inner_cell
    integer :: num_cells_edge
    integer :: last_edge_cell
    integer :: num_cells_halo
    integer :: last_halo_cell
    integer(i_def) :: num_cells_ghost
    integer :: cell_owner
    integer :: lid
    integer :: gid

    integer(i_def) :: npanels
    integer(i_def) :: global_mesh_id
    integer(i_native) :: num_processes

    character(len = str_max_filename) :: filename

    num_processes = this%context%getNumProcesses()
    select case (num_processes)
      case (1)
        xproc = 1
        yproc = 1
      case (4)
        xproc = 2
        yproc = 2
    end select

    local_rank = this%local_rank
    total_ranks = this%total_ranks
    max_stencil_depth = 1

    filename = 'data/mesh_planar.nc'
    npanels  = 1

    global_mesh_id =  global_mesh_collection%add_new_global_mesh( filename,  &
                                                                  mesh_name, &
                                                                  npanels )

    global_mesh    => global_mesh_collection%get_global_mesh( global_mesh_id )

    partitioner_ptr => partitioner_planar
    !
    ! Generate the partition
    partition = partition_type( global_mesh, &
                                partitioner_ptr, &
                                xproc, &
                                yproc, &
                                max_stencil_depth, &
                                local_rank, &
                                total_ranks )
    ! Test functionality of the partition object we've just created on both 1
    ! and 4 processes
    select case (num_processes)

      case (1)
        num_cells_in_layer = partition%get_num_cells_in_layer()
        @assertEqual( 64, num_cells_in_layer )

        inner_depth = partition%get_inner_depth()
        @assertEqual( 2, inner_depth )

        num_cells_inner = partition%get_num_cells_inner(1)
        @assertEqual( 20, num_cells_inner )

        last_inner_cell = partition%get_last_inner_cell(1)
        @assertEqual( 36, last_inner_cell )

        num_cells_edge = partition%get_num_cells_edge()
        @assertEqual( 28, num_cells_edge )

        last_edge_cell = partition%get_last_edge_cell()
        @assertEqual( 64, last_edge_cell )

        halo_depth = partition%get_halo_depth()
        @assertEqual( 2, halo_depth )

        num_cells_halo = partition%get_num_cells_halo(1)
        @assertEqual( 0, num_cells_halo )

        last_halo_cell = partition%get_last_halo_cell(1)
        @assertEqual( 64, last_halo_cell )

        num_cells_ghost = partition%get_num_cells_ghost()
        @assertEqual( 0, num_cells_ghost )

        cell_owner = partition%get_cell_owner( 1 )
        @assertEqual( 0, cell_owner )

        lid = 1
        gid = partition%get_gid_from_lid( lid )
        @assertEqual( 19, gid )

        gid = 30
        lid = partition%get_lid_from_gid( gid )
        @assertEqual( 8, lid )

      case (4)
        num_cells_in_layer = partition%get_num_cells_in_layer()
        @assertEqual( 36, num_cells_in_layer )

        inner_depth = partition%get_inner_depth()
        @assertEqual( 2, inner_depth )

        num_cells_inner = partition%get_num_cells_inner(1)
        @assertEqual( 4, num_cells_inner )

        last_inner_cell = partition%get_last_inner_cell(1)
        @assertEqual( 4, last_inner_cell )

        num_cells_edge = partition%get_num_cells_edge()
        @assertEqual( 12, num_cells_edge )

        last_edge_cell = partition%get_last_edge_cell()
        @assertEqual( 16, last_edge_cell )

        halo_depth = partition%get_halo_depth()
        @assertEqual( 2, halo_depth )

        num_cells_halo = partition%get_num_cells_halo(1)
        @assertEqual( 9, num_cells_halo )

        last_halo_cell = partition%get_last_halo_cell(1)
        @assertEqual( 25, last_halo_cell )

        num_cells_ghost = partition%get_num_cells_ghost()
        @assertEqual( 13, num_cells_ghost )

        cell_owner = partition%get_cell_owner(1)
        @assertEqual( local_rank, cell_owner )

        lid = 1
        gid = partition%get_gid_from_lid( lid )
        select case (local_rank)
          case (0)
            @assertEqual( 42, gid )
          case (1)
            @assertEqual( 46, gid )
          case (2)
            @assertEqual( 10, gid )
          case (3)
            @assertEqual( 14, gid )
        end select

        gid = 30
        lid = partition%get_lid_from_gid( gid )
        select case (local_rank)
          case (0)
            @assertEqual( 32, lid )
          case (1)
            @assertEqual( 19, lid )
          case (2)
            @assertEqual( 29, lid )
          case (3)
            @assertEqual( 14, lid )
        end select

    end select

  end subroutine test_partition_planar

  @Test(npes=[1, 4] )
  subroutine test_partition_trench_x( this )

    implicit none

    class( partition_test_type ), intent( inout ) :: this

    type(global_mesh_type), pointer :: global_mesh => null()
    type(partition_type)            :: partition

    procedure (partitioner_interface), pointer :: partitioner_ptr => null()

    integer :: xproc
    integer :: yproc
    integer :: local_rank
    integer :: total_ranks
    integer :: max_stencil_depth

    integer :: num_cells_in_layer
    integer :: inner_depth
    integer :: halo_depth
    integer :: num_cells_inner
    integer :: last_inner_cell
    integer :: num_cells_edge
    integer :: last_edge_cell
    integer :: num_cells_halo
    integer :: last_halo_cell
    integer(i_def) :: num_cells_ghost
    integer :: cell_owner
    integer :: lid
    integer :: gid

    integer(i_def) :: npanels
    integer(i_def) :: global_mesh_id
    integer(i_native) :: num_processes

    character(len = str_max_filename) :: filename

    num_processes = this%context%getNumProcesses()
    select case (num_processes)
      case (1)
        xproc = 1
        yproc = 1
      case (4)
        xproc = 2
        yproc = 2
    end select

    local_rank = this%local_rank
    total_ranks = this%total_ranks
    max_stencil_depth = 1

    filename = 'data/mesh_trench_x.nc'
    npanels  = 1

    global_mesh_id =  global_mesh_collection%add_new_global_mesh( filename,  &
                                                                  mesh_name, &
                                                                  npanels )

    global_mesh    => global_mesh_collection%get_global_mesh( global_mesh_id )

    partitioner_ptr => partitioner_planar
    !
    ! Generate the partition
    partition = partition_type( global_mesh, &
                                partitioner_ptr, &
                                xproc, &
                                yproc, &
                                max_stencil_depth, &
                                local_rank, &
                                total_ranks )
    ! Test functionality of the partition object we've just created on both 1
    ! and 4 processes
    select case (num_processes)

      case (1)
        num_cells_in_layer = partition%get_num_cells_in_layer()
        @assertEqual( 64, num_cells_in_layer )

        inner_depth = partition%get_inner_depth()
        @assertEqual( 2, inner_depth )

        num_cells_inner = partition%get_num_cells_inner(1)
        @assertEqual( 20, num_cells_inner )

        last_inner_cell = partition%get_last_inner_cell(1)
        @assertEqual( 36, last_inner_cell )

        num_cells_edge = partition%get_num_cells_edge()
        @assertEqual( 28, num_cells_edge )

        last_edge_cell = partition%get_last_edge_cell()
        @assertEqual( 64, last_edge_cell )

        halo_depth = partition%get_halo_depth()
        @assertEqual( 2, halo_depth )

        num_cells_halo = partition%get_num_cells_halo(1)
        @assertEqual( 0, num_cells_halo )

        last_halo_cell = partition%get_last_halo_cell(1)
        @assertEqual( 64, last_halo_cell )

        num_cells_ghost = partition%get_num_cells_ghost()
        @assertEqual( 0, num_cells_ghost )

        cell_owner = partition%get_cell_owner( 1 )
        @assertEqual( 0, cell_owner )

        lid = 1
        gid = partition%get_gid_from_lid( lid )
        @assertEqual( 19, gid )

        gid = 30
        lid = partition%get_lid_from_gid( gid )
        @assertEqual( 8, lid )

      case (4)
        num_cells_in_layer = partition%get_num_cells_in_layer()
        @assertEqual( 48, num_cells_in_layer )

        inner_depth = partition%get_inner_depth()
        @assertEqual( 2, inner_depth )

        num_cells_inner = partition%get_num_cells_inner(1)
        @assertEqual( 4, num_cells_inner )

        last_inner_cell = partition%get_last_inner_cell(1)
        @assertEqual( 4, last_inner_cell )

        num_cells_edge = partition%get_num_cells_edge()
        @assertEqual( 12, num_cells_edge )

        last_edge_cell = partition%get_last_edge_cell()
        @assertEqual( 16, last_edge_cell )

        halo_depth = partition%get_halo_depth()
        @assertEqual( 2, halo_depth )

        num_cells_halo = partition%get_num_cells_halo(1)
        @assertEqual( 14, num_cells_halo )

        last_halo_cell = partition%get_last_halo_cell(1)
        @assertEqual( 30, last_halo_cell )

        num_cells_ghost = partition%get_num_cells_ghost()
        @assertEqual( 8, num_cells_ghost )

        cell_owner = partition%get_cell_owner(1)
        @assertEqual( local_rank, cell_owner )

        lid = 1
        gid = partition%get_gid_from_lid( lid )
        select case (local_rank)
          case (0)
            @assertEqual( 42, gid )
          case (1)
            @assertEqual( 46, gid )
          case (2)
            @assertEqual( 10, gid )
          case (3)
            @assertEqual( 14, gid )
        end select

        gid = 30
        lid = partition%get_lid_from_gid( gid )
        select case (local_rank)
          case (0)
            @assertEqual( 39, lid )
          case (1)
            @assertEqual( 20, lid )
          case (2)
            @assertEqual( 37, lid )
          case (3)
            @assertEqual( 14, lid )
        end select

    end select

  end subroutine test_partition_trench_x

  @Test(npes=[1, 4] )
  subroutine test_partition_trench_y( this )

    implicit none

    class( partition_test_type ), intent( inout ) :: this

    type(global_mesh_type), pointer :: global_mesh => null()
    type(partition_type)            :: partition

    procedure (partitioner_interface), pointer :: partitioner_ptr => null()

    integer :: xproc
    integer :: yproc
    integer :: local_rank
    integer :: total_ranks
    integer :: max_stencil_depth

    integer :: num_cells_in_layer
    integer :: inner_depth
    integer :: halo_depth
    integer :: num_cells_inner
    integer :: last_inner_cell
    integer :: num_cells_edge
    integer :: last_edge_cell
    integer :: num_cells_halo
    integer :: last_halo_cell
    integer(i_def) :: num_cells_ghost
    integer :: cell_owner
    integer :: lid
    integer :: gid

    integer(i_def) :: npanels
    integer(i_def) :: global_mesh_id
    integer(i_native) :: num_processes

    character(len = str_max_filename) :: filename

    num_processes = this%context%getNumProcesses()
    select case (num_processes)
      case (1)
        xproc = 1
        yproc = 1
      case (4)
        xproc = 2
        yproc = 2
    end select

    local_rank = this%local_rank
    total_ranks = this%total_ranks
    max_stencil_depth = 1

    filename = 'data/mesh_trench_y.nc'
    npanels  = 1

    global_mesh_id =  global_mesh_collection%add_new_global_mesh( filename,  &
                                                                  mesh_name, &
                                                                  npanels )

    global_mesh    => global_mesh_collection%get_global_mesh( global_mesh_id )

    partitioner_ptr => partitioner_planar
    !
    ! Generate the partition
    partition = partition_type( global_mesh, &
                                partitioner_ptr, &
                                xproc, &
                                yproc, &
                                max_stencil_depth, &
                                local_rank, &
                                total_ranks )
    ! Test functionality of the partition object we've just created on both 1
    ! and 4 processes
    select case (num_processes)

      case (1)
        num_cells_in_layer = partition%get_num_cells_in_layer()
        @assertEqual( 64, num_cells_in_layer )

        inner_depth = partition%get_inner_depth()
        @assertEqual( 2, inner_depth )

        num_cells_inner = partition%get_num_cells_inner(1)
        @assertEqual( 20, num_cells_inner )

        last_inner_cell = partition%get_last_inner_cell(1)
        @assertEqual( 36, last_inner_cell )

        num_cells_edge = partition%get_num_cells_edge()
        @assertEqual( 28, num_cells_edge )

        last_edge_cell = partition%get_last_edge_cell()
        @assertEqual( 64, last_edge_cell )

        halo_depth = partition%get_halo_depth()
        @assertEqual( 2, halo_depth )

        num_cells_halo = partition%get_num_cells_halo(1)
        @assertEqual( 0, num_cells_halo )

        last_halo_cell = partition%get_last_halo_cell(1)
        @assertEqual( 64, last_halo_cell )

        num_cells_ghost = partition%get_num_cells_ghost()
        @assertEqual( 0, num_cells_ghost )

        cell_owner = partition%get_cell_owner( 1 )
        @assertEqual( 0, cell_owner )

        lid = 1
        gid = partition%get_gid_from_lid( lid )
        @assertEqual( 27, gid )

        gid = 30
        lid = partition%get_lid_from_gid( gid )
        @assertEqual( 4, lid )

      case (4)
        num_cells_in_layer = partition%get_num_cells_in_layer()
        @assertEqual( 48, num_cells_in_layer )

        inner_depth = partition%get_inner_depth()
        @assertEqual( 2, inner_depth )

        num_cells_inner = partition%get_num_cells_inner(1)
        @assertEqual( 4, num_cells_inner )

        last_inner_cell = partition%get_last_inner_cell(1)
        @assertEqual( 4, last_inner_cell )

        num_cells_edge = partition%get_num_cells_edge()
        @assertEqual( 12, num_cells_edge )

        last_edge_cell = partition%get_last_edge_cell()
        @assertEqual( 16, last_edge_cell )

        halo_depth = partition%get_halo_depth()
        @assertEqual( 2, halo_depth )

        num_cells_halo = partition%get_num_cells_halo(1)
        @assertEqual( 14, num_cells_halo )

        last_halo_cell = partition%get_last_halo_cell(1)
        @assertEqual( 30, last_halo_cell )

        num_cells_ghost = partition%get_num_cells_ghost()
        @assertEqual( 8, num_cells_ghost )

        cell_owner = partition%get_cell_owner(1)
        @assertEqual( local_rank, cell_owner )

        lid = 1
        gid = partition%get_gid_from_lid( lid )
        select case (local_rank)
          case (0)
            @assertEqual( 50, gid )
          case (1)
            @assertEqual( 54, gid )
          case (2)
            @assertEqual( 18, gid )
          case (3)
            @assertEqual( 22, gid )
        end select

        gid = 30
        lid = partition%get_lid_from_gid( gid )
        select case (local_rank)
          case (0)
            @assertEqual( 44, lid )
          case (1)
            @assertEqual( 42, lid )
          case (2)
            @assertEqual( 34, lid )
          case (3)
            @assertEqual( 3, lid )
        end select

    end select

  end subroutine test_partition_trench_y

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! Test partition_cubedsphere_serial (on a single process)
  !
  @Test( npes=[1] )
  subroutine test_partition_CubedSphere( this )

    implicit none

    class( partition_test_type ), intent( inout ) :: this

    type(global_mesh_type), pointer :: global_mesh => null()
    type(partition_type)            :: partition

    procedure (partitioner_interface), pointer :: partitioner_ptr => null()

    integer :: xproc
    integer :: yproc
    integer :: local_rank
    integer :: total_ranks
    integer :: max_stencil_depth

    integer :: num_cells_in_layer
    integer :: inner_depth
    integer :: halo_depth
    integer :: num_cells_inner
    integer :: last_inner_cell
    integer :: num_cells_edge
    integer :: last_edge_cell
    integer :: num_cells_halo
    integer :: last_halo_cell
    integer(i_def) :: num_cells_ghost
    integer :: cell_owner
    integer :: lid
    integer :: gid

    integer(i_def) :: npanels
    integer(i_def) :: global_mesh_id

    character(len = str_max_filename) :: filename

    xproc = 1
    yproc = 1
    local_rank = this%local_rank
    total_ranks = this%total_ranks
    max_stencil_depth = 1

    filename = 'data/mesh_C4.nc'
    npanels  = 6
    global_mesh_id =  global_mesh_collection%add_new_global_mesh( filename,  &
                                                                  mesh_name, &
                                                                  npanels )
    global_mesh    => global_mesh_collection%get_global_mesh( global_mesh_id )

    partitioner_ptr => partitioner_cubedsphere_serial

    partition = partition_type( global_mesh, &
                                partitioner_ptr, &
                                xproc, &
                                yproc, &
                                max_stencil_depth, &
                                local_rank, &
                                total_ranks )
    !
    ! Test functionality of the partition object we've just created
    num_cells_in_layer = partition%get_num_cells_in_layer()
    @assertEqual( 96, num_cells_in_layer )

    inner_depth = partition%get_inner_depth()
    @assertEqual( 2, inner_depth )

    num_cells_inner = partition%get_num_cells_inner(2)
    @assertEqual( 96, num_cells_inner )

    last_inner_cell = partition%get_last_inner_cell(1)
    @assertEqual( 96, last_inner_cell )

    num_cells_edge = partition%get_num_cells_edge()
    @assertEqual( 0, num_cells_edge )

    last_edge_cell = partition%get_last_edge_cell()
    @assertEqual( 96, last_edge_cell )

    halo_depth = partition%get_halo_depth()
    @assertEqual( 2, halo_depth )

    num_cells_halo = partition%get_num_cells_halo(1)
    @assertEqual( 0, num_cells_halo )

    last_halo_cell = partition%get_last_halo_cell(1)
    @assertEqual( 96, last_halo_cell )

    num_cells_ghost = partition%get_num_cells_ghost()
    @assertEqual( 0, num_cells_ghost )

    cell_owner = partition%get_cell_owner( 1 )
    @assertEqual( 0, cell_owner )

    lid = 1
    gid = partition%get_gid_from_lid( lid )
    @assertEqual( 1, gid )

    gid = 96
    lid = partition%get_lid_from_gid( gid )
    @assertEqual( 96, lid )

    !> @todo Can't test a parallel cubed-sphere partition at this time, details
    !>       are described in ticket #1985.
    !
    !  !----------------------------------------
    !  !Test partition_cubedsphere (in parallel)
    !  !----------------------------------------
    !  xproc = 2
    !  yproc = 2
    !  local_rank = this%local_rank
    !  total_ranks = this%total_ranks
    !  max_stencil_depth = 2
    !
    !  filename = 'data/ugrid_quads_2d.nc'
    !  global_mesh = global_mesh_type( filename )
    !  partitioner_ptr => partitioner_cubedsphere
    !
    !  partition = partition_type( global_mesh, &
    !                              partitioner_ptr, &
    !                              xproc, &
    !                              yproc, &
    !                              max_stencil_depth, &
    !                              local_rank, &
    !                              total_ranks )
    !  !
    !  ! Test functionality of the partition object we've just created
    !  ...

  end subroutine test_partition_CubedSphere

end module partition_mod_test
