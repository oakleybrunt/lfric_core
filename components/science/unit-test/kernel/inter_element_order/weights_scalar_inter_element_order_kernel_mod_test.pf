!-----------------------------------------------------------------------------
! (C) Crown copyright 2025 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> Test the mapping of a higher order space to a lower order space on a finer
!! mesh.
module weights_scalar_inter_element_order_kernel_mod_test

  use, intrinsic :: iso_fortran_env,     only: real64
  use funit
  use constants_mod,                     only: i_def, r_def
  use inter_element_order_test_data_mod, only: w3_fe_to_fv_weights, &
                                               w3_fv_to_fe_weights

  implicit none

contains

  @test
  subroutine test_all
    use sci_weights_scalar_inter_element_order_kernel_mod, &
                                 only: weights_scalar_inter_element_order_code

    implicit none

    ! Scalars
    integer(kind=i_def) :: lp_x, lp_y, df, cell, k
    integer(kind=i_def) :: nlayers
    integer(kind=i_def) :: ncell_f_per_c_x ! Number of fine cells per coarse in x
    integer(kind=i_def) :: ncell_f_per_c_y ! Number of fine cells per coarse in y
    integer(kind=i_def) :: ncell_f         ! Number of fine cells
    integer(kind=i_def) :: ndf_f           ! Number of dofs per fine cell
    integer(kind=i_def) :: ndf_c           ! Number of dofs per coarse cell
    integer(kind=i_def) :: undf_f, undf_c  ! Number of dofs on the mesh
    integer(kind=i_def) :: undf_weights    ! Number of dofs on the weights field
    integer(kind=i_def) :: ndata           ! Number of data points per dof in weights field
    integer(kind=i_def) :: nqp_xy, nqp_z
    real(kind=r_def)    :: x, y
    real(kind=r_def)    :: use_tol

    ! Integer Arrays
    integer(kind=i_def), allocatable, dimension(:,:) :: cell_map
    integer(kind=i_def), allocatable, dimension(:,:) :: map_f ! Cell and dof indexed
    integer(kind=i_def), allocatable, dimension(:)   :: map_c ! Only dof indexed
    integer(kind=i_def), allocatable, dimension(:)   :: map_weights

    ! Real Arrays
    real(kind=r_def), allocatable, dimension(:) :: coarse_field,     &
                                                   fine_field,       &
                                                   test_weights,     &
                                                   test_inv_weights
    real(kind=r_def), allocatable, dimension(:,:,:,:) :: basis_coarse
    real(kind=r_def), allocatable, dimension(:,:)     :: qr_xy, qr_z

    ! Pointers
    real(kind=r_def), pointer :: weights(:)
    real(kind=r_def), pointer :: inv_weights(:)

    ! Parameters
    real(kind=r_def), parameter :: tol = 1.0e-12_r_def

    if (r_def == real64) then
      use_tol = tol
    else
      use_tol = 10.0_r_def*spacing(1.0_r_def)
    end if

    ! Set scalars
    nlayers = 3
    ncell_f_per_c_x = 2
    ncell_f_per_c_y = 2
    ndf_f = 1 ! W3, discontinuous
    ncell_f = ndf_f * ncell_f_per_c_x * ncell_f_per_c_y
    ndf_c = 4 ! Linear in horizontal, constant in vertical
    undf_f = nlayers * ncell_f * ndf_f
    undf_c = nlayers * ndf_c
    ndata = 4
    undf_weights = ndf_c*ncell_f
    nqp_xy = 4
    nqp_z = 1

    allocate( cell_map(ncell_f_per_c_x,  &
                       ncell_f_per_c_y), &
              map_f(ndf_f,ncell_f),      &
              map_c(ndf_c),              &
              map_weights(ndf_c) )
    allocate( coarse_field(undf_c),           &
              fine_field(undf_f),             &
              test_weights(undf_weights),     &
              test_inv_weights(undf_weights) )
    allocate( basis_coarse(1, ndf_c, ncell_f, 1) )
    allocate( qr_xy(nqp_xy, 2), &
              qr_z(nqp_z, 2) )

    ! Set simple values for index sets
    do lp_y = 1, ncell_f_per_c_y
      do lp_x = 1, ncell_f_per_c_x
        cell_map(lp_x, lp_y) = lp_x + (lp_y - 1)*ncell_f_per_c_y
      end do
    end do
    do cell = 1, ncell_f
       map_f(1,cell) = 1 + (cell-1)*nlayers
    end do
    do df = 1, ndf_c
      map_c(df) = 1 + (df-1)*nlayers
    end do
    do df = 1, ndf_c
      map_weights(df) = 1 + ndata*(df-1)
    end do

    ! Set simple values for the fields
    do k = 0, nlayers - 1
      do df = 1, ndf_c
        coarse_field(map_c(df) + k) = real(df + 10*k, r_def)
      end do
    end do
    fine_field(:) = 0.0_r_def

    ! Quadrature points are the fine dof locations in the coarse mesh, given by
    ! the segment centre quadrature rule
    qr_xy(:,1) = (/ 1.0_r_def, 3.0_r_def, 5.0_r_def /)/6.0_r_def
    qr_xy(:,2) = (/ 3.0_r_def, 2.0_r_def, 3.0_r_def /)/8.0_r_def
    qr_z(:,1)  = 0.5_r_def
    qr_z(:,2)  = 1.0_r_def

    ! Basis coarse is the coarse basis functions evaluated at the fine dofs
    do df = 1, ndf_c
      do lp_y = 1, ncell_f_per_c_y
        do lp_x = 1, ncell_f_per_c_x
          x = 0.25_r_def
          y = 0.25_r_def
          if(lp_x == 2) x = 0.75_r_def
          if(lp_y == 2) y = 0.75_r_def
          if (df == 1) then
            basis_coarse(1,df,cell_map(lp_x, lp_y),1) = &
              (1.0_r_def - x)*(1.0_r_def - y)
          else if (df == 2) then
            basis_coarse(1,df,cell_map(lp_x, lp_y),1) = &
              x*(1.0_r_def - y)
          else if (df == 3) then
            basis_coarse(1,df,cell_map(lp_x, lp_y),1) = &
              x*y
          else if (df == 4) then
            basis_coarse(1,df,cell_map(lp_x, lp_y),1) = &
              (1.0_r_def - x)*y
          else
            basis_coarse(1,df,cell_map(lp_x, lp_y),1) = 0.0_r_def
          end if
        end do
      end do
    end do

    ! Test weights for mapping both directions
    weights => w3_fe_to_fv_weights
    inv_weights => w3_fv_to_fe_weights

    call weights_scalar_inter_element_order_code( &
                                nlayers,          &
                                cell_map,         &
                                ncell_f_per_c_x,  &
                                ncell_f_per_c_y,  &
                                ncell_f,          &
                                fine_field,       &
                                coarse_field,     &
                                test_weights,     &
                                test_inv_weights, &
                                ndf_f,            &
                                undf_f,           &
                                map_f,            &
                                ndf_c,            &
                                undf_c,           &
                                map_c,            &
                                basis_coarse,     &
                                undf_weights,     &
                                map_weights,      &
                                nqp_xy,           &
                                nqp_z,            &
                                qr_xy(:,2),       &
                                qr_z(:,2))

    @assertEqual(weights, test_weights, use_tol)
    @assertEqual(inv_weights, test_inv_weights, use_tol)


    deallocate( cell_map,         &
                map_f,            &
                map_c,            &
                map_weights,      &
                coarse_field,     &
                fine_field,       &
                test_weights,     &
                test_inv_weights, &
                basis_coarse,     &
                qr_xy,            &
                qr_z )

    nullify( weights, &
             inv_weights )

  end subroutine test_all

end module weights_scalar_inter_element_order_kernel_mod_test
