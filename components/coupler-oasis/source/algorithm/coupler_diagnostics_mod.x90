!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief This modules handles calculation of the diagnostics sent to other components

module coupler_diagnostics_mod
  use field_mod,                     only: field_type
  use field_collection_mod,          only: field_collection_type
  use clock_mod,                     only: clock_type
  use constants_mod,                 only: str_def, l_def, i_def, r_def, imdi, i_timestep
  use log_mod,                       only: log_event,       &
                                           LOG_LEVEL_INFO,  &
                                           LOG_LEVEL_ERROR, &
                                           log_scratch_space
  implicit none
  private
  type( field_type )                 :: field1, field2, field3      ! scratch fields to derive values for coupling
                                                                    ! allocated in cpl_define
  public field1, field2, field3
  public cpl_diagnostics, cpl_reset_field

  contains

  !> @brief assignes data to coupling fields
  !> @param[in, out] fld coupling field
  !> @param[in] depository field collection - all fields
  !> @param[in] clock model clock
  !> @param[in] dn_sea_tile index of the sea tile
  !> @param[in] dfirst_sea_tile index of the first sea and tile
  !> @param[in] hlat latent_heat condensation
  !> @param[in] istep model time step
  subroutine cpl_diagnostics(fld, depository, clock, dn_sea_tile, &
                                            dfirst_sea_tile, hlat, istep)

   use multi_extract_kernel_mod,    only: multi_extract_kernel_type
   implicit none
   type( field_type ), intent(inout)            :: fld
   type( field_collection_type ), intent(in)    :: depository
   class(clock_type), intent(in)                :: clock
   integer(i_def), intent(in)                   :: istep
   integer(kind=i_def), intent(in)              :: dfirst_sea_tile
   integer(kind=i_def), intent(in)              :: dn_sea_tile
   real(kind=r_def), intent(in)                 :: hlat
   ! Local variables
   logical(l_def)                               :: lfail    ! failure flag

   ! PSyclone requires field types to be discoverable within the algorithm.
   ! Therefore depository fields need to be dereferenced to a known type
   ! before calling invokes
   type( field_type ), pointer                  :: fld_ptr1, fld_ptr2 => null()
   type( field_type ), pointer                  :: fld_ptr3, fld_ptr4 => null()

   real(r_def)                                  :: dtime    ! seconds in timestep

   lfail = .false.

   if(istep > 1) then
      dtime = real(clock%get_seconds_per_step(), r_def)
      select case(fld%get_name())
         case ("lf_taux")
            fld_ptr1 => depository%get_field("taux")
            call invoke(inc_X_plus_bY( fld, dtime, fld_ptr1 ))
            fld_ptr1 => null()
         case ("lf_tauy")
            fld_ptr1 => depository%get_field("tauy")
            call invoke(inc_X_plus_bY( fld, dtime, fld_ptr1 ))
            fld_ptr1 => null()
         case ("lf_solar")
            fld_ptr1 => depository%get_field("sw_up_tile")
            fld_ptr2 => depository%get_field("sw_down_surf")

            call invoke( multi_extract_kernel_type(field1,                   &
                      fld_ptr1,                                              &
                      dfirst_sea_tile, dn_sea_tile),                         &
                      X_minus_Y(field2, fld_ptr2, field1) )
            call invoke(inc_X_plus_bY( fld, dtime, field2 ))
            fld_ptr1 => null()
            fld_ptr2 => null()
         case ("lf_heatflux")
           !longwave lw_down_surf - lw_up_tile
           fld_ptr1 => depository%get_field("lw_up_tile")
           fld_ptr2 => depository%get_field("lw_down_surf")
           fld_ptr3 => depository%get_field("tile_heat_flux")
           fld_ptr4 => depository%get_field("tile_moisture_flux")
           call invoke( multi_extract_kernel_type(field1,                    &
                        fld_ptr1,                                            &
                        dfirst_sea_tile, dn_sea_tile),                       &
                        X_minus_Y(field2, fld_ptr2, field1) )
            ! add longwave
            call invoke(inc_X_plus_bY(fld, dtime, field1))
            ! sensible heat flux - field1, moisture heat flux - field2
            call invoke(multi_extract_kernel_type(field1,         &
                                              fld_ptr3,           &
                           dfirst_sea_tile, dn_sea_tile),         &
                        multi_extract_kernel_type(field2,         &
                                              fld_ptr4,           &
                           dfirst_sea_tile, dn_sea_tile))
            ! field3 = field1 + hlat*field2
            call invoke(aX_plus_bY(field3, 1._r_def, field1, hlat, field2))
            call invoke(inc_X_minus_bY( fld, dtime, field3 ))
            fld_ptr1 => null()
            fld_ptr2 => null()
            fld_ptr3 => null()
            fld_ptr4 => null()
         case default
            lfail = .true.
            write(log_scratch_space, '(3A)' )                                 &
                                         "PROBLEM cpl_diagnostics variable ", &
                                trim(fld%get_name()), ": can not assign value"
            call log_event( log_scratch_space, LOG_LEVEL_INFO )
      end select
   else if(istep == 0) then
     !for now. It will be set by restart when available
      call cpl_reset_field(fld)
      write(log_scratch_space, '(2A)' ) "cpl_diagnostics: variable ",  &
                                   trim(fld%get_name())//": set to 0"
      call log_event( log_scratch_space, LOG_LEVEL_INFO )
   endif

   if(lfail) then
      write(log_scratch_space, * ) "ERRORS in cpl_diagnostics"
      call log_event( log_scratch_space, LOG_LEVEL_ERROR )
   endif

  end subroutine cpl_diagnostics

  !> @brief sets value af fld to 0
  !> @param[in, out] fld coupling field
  subroutine cpl_reset_field(fld)
   implicit none
   type( field_type ), intent(inout) :: fld

   call invoke(setval_c(fld, 0.0_r_def))

  end subroutine cpl_reset_field

end module coupler_diagnostics_mod
