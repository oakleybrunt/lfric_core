!-----------------------------------------------------------------------------
! (c) Crown copyright 2023 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> LFRic unit tests for jedi_datetime_functions_mod.
!> LFRic unit tests use pfUnit, a Fortran unit test framework written by NASA.
!> This particular example tests the result of a matrix vector calculation
!> using the code from the matrix_vector_kernel_mod in the LFRic science
!> component.
!>
!-------------------------------------------------------------------------------
module lfric_da_datetime_functions_mod_test

  ! Global use statements go here

  use constants_mod, only : i_def, l_def

  use pFUnit_Mod

  implicit none

  private
  public :: lfric_da_datetime_functions_test

  ! The test case type, containing procedures to setup, run
  ! and clean up after a test.
  ! It can also contain data.

  @TestCase
  type, extends(TestCase), public :: lfric_da_datetime_functions_test_type
    private
  contains
    procedure setUp
    procedure tearDown
    procedure lfric_da_datetime_functions_test
  end type lfric_da_datetime_functions_test_type


contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !> The setUp subroutine is optional and is called prior to running the test.
  !> It is used to create and initialise types / data that are used in
  !> the tests
  subroutine setUp( this )

    implicit none

    class(lfric_da_datetime_functions_test_type), intent(inout) :: this

    ! This section should create and initialise anything needed for the test

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !> The tearDown subroutine is optional and called after the test.
  !> It is used to destroy any types / data previously created by setUp()
  subroutine tearDown( this )


    implicit none

    class(lfric_da_datetime_functions_test_type), intent(inout) :: this

    ! This section should destroy any previously created types / data

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! pfUnit will run each subroutine preceded by the @test line
  @test
  !> Test the emulated jedi_datetime_functions mod
  subroutine lfric_da_datetime_functions_test( this )


    use lfric_da_datetime_functions_mod, only : YYYYMMDD_to_JDN,   &
                                                JDN_to_YYYYMMDD,   &
                                                hhmmss_to_seconds, &
                                                seconds_to_hhmmss, &
                                                is_valid_YYYYMMDD, &
                                                is_leap_year,      &
                                                is_valid_hhmmss,   &
                                                is_valid_datetime

    implicit none

    class(lfric_da_datetime_functions_test_type), intent(inout) :: this

    integer(i_def) :: year, returned_year
    integer(i_def) :: month, returned_month
    integer(i_def) :: day, returned_day

    integer(i_def) :: julian_day_number, returned_julian_day_number

    integer(i_def) :: hour, returned_hour
    integer(i_def) :: minute, returned_minute
    integer(i_def) :: second, returned_second

    integer(i_def) :: time_seconds, returned_time_seconds

    logical(l_def) :: valid

    ! Test YYYYMMDD_to_JDN conversion to Julian Day Number
    year  = 2023_i_def
    month = 04_i_def
    day   = 05_i_def

    julian_day_number = 2460040_i_def

    call YYYYMMDD_to_JDN( year, month, day, returned_julian_day_number )
    @assertEqual( julian_day_number, returned_julian_day_number )

    ! Test JDN_to_YYYYMMDD conversion to year, month, day
    call JDN_to_YYYYMMDD( julian_day_number, returned_year, &
                          returned_month, returned_day )
    @assertEqual( year, returned_year )
    @assertEqual( month, returned_month )
    @assertEqual( day, returned_day )

    ! Test hhmmss_to_seconds
    hour   = 16_i_def
    minute = 19_i_def
    second = 30_i_def

    time_seconds = 58770_i_def

    call hhmmss_to_seconds( hour, minute, second, returned_time_seconds )
    @assertEqual( time_seconds, returned_time_seconds )

    ! Test seconds_to_hhmmss
    call seconds_to_hhmmss( time_seconds, returned_hour, &
                            returned_minute, returned_second )
    @assertEqual( hour, returned_hour )
    @assertEqual( minute, returned_minute )
    @assertEqual( second, returned_second )

    ! Logic tests
    ! year, month, day tests
    valid = is_valid_YYYYMMDD( year, month, day )        ! good date
    @assertEqual( .true., valid )

    valid = is_valid_YYYYMMDD( -5000_i_def, month, day ) ! bad year
    @assertEqual( .false., valid )

    valid = is_valid_YYYYMMDD( year, 13_i_def, day )     ! bad month
    @assertEqual( .false., valid )
    valid = is_valid_YYYYMMDD( year, 00_i_def, day )     ! bad month
    @assertEqual( .false., valid )

    valid = is_valid_YYYYMMDD( year, month, 32_i_def )   ! bad day
    @assertEqual( .false., valid )
    valid = is_valid_YYYYMMDD( year, month, 00_i_def )   ! bad day
    @assertEqual( .false., valid )

    valid = is_valid_YYYYMMDD( 2023_i_def, 02_i_def, 29_i_def ) ! Feb non leap
    @assertEqual( .false., valid )
    valid = is_valid_YYYYMMDD( 2024_i_def, 02_i_def, 29_i_def ) ! Feb leap
    @assertEqual( .true., valid )

    ! leap year tests
    valid = is_leap_year( 2021_i_def )
    @assertEqual( .false., valid )

    valid = is_leap_year( 2000_i_def )
    @assertEqual( .true., valid )

    valid = is_leap_year( 2024_i_def )
    @assertEqual( .true., valid )

    ! hour, minute, day tests
    valid = is_valid_hhmmss( hour, minute, second )      ! good time
    @assertEqual( .true., valid )

    valid = is_valid_hhmmss( -01_i_def, minute, second ) ! bad hour
    @assertEqual( .false., valid )
    valid = is_valid_hhmmss( 24_i_def, minute, second )  ! bad hour
    @assertEqual( .false., valid )

    valid = is_valid_hhmmss( hour, -01_i_def, second ) ! bad minute
    @assertEqual( .false., valid )
    valid = is_valid_hhmmss( hour, 60_i_def, second )  ! bad minute
    @assertEqual( .false., valid )

    valid = is_valid_hhmmss( hour, minute, -01_i_def ) ! bad second
    @assertEqual( .false., valid )
    valid = is_valid_hhmmss( hour, minute, 60_i_def )  ! bad second
    @assertEqual( .false., valid )

    ! date time test
    valid = is_valid_datetime( 2460040_i_def, 58770_i_def )
    @assertEqual( .true., valid )

  end subroutine lfric_da_datetime_functions_test

end module lfric_da_datetime_functions_mod_test
