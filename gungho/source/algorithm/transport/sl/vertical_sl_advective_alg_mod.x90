!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief An algorithm for performing 1D vertical semi-Lagrangian advective transport.
!> @details The algorithm performs a 1D vertical semi-Lagrangian advective
!!          transport of a field. It computes the field at the departure point
!!          using a cubic or quintic interpolation.

module vertical_sl_advective_alg_mod

  use end_of_transport_step_alg_mod,      only: end_of_advective_step_alg
  use constants_mod,                      only: r_tran, i_def, l_def
  use io_config_mod,                      only: subroutine_timers
  use timer_mod,                          only: timer
  use field_mod,                          only: field_type
  use r_tran_field_mod,                   only: r_tran_field_type
  use vertical_sl_theta_kernel_mod,       only: vertical_sl_theta_kernel_type
  use vertical_sl_rho_kernel_mod,         only: vertical_sl_rho_kernel_type
  use transport_config_mod,               only: vertical_sl_order,         &
                                                vertical_sl_order_cubic,   &
                                                vertical_sl_order_quintic, &
                                                vertical_sl_order_cubic_hermite
  use log_mod,                            only: log_event, LOG_LEVEL_ERROR
  use mesh_mod,                           only: mesh_type
  use transport_enumerated_types_mod,     only: splitting_strang_vhv
  use transport_metadata_mod,             only: transport_metadata_type
  use transport_runtime_alg_mod,          only: transport_runtime_type
  use transport_runtime_collection_mod,   only: get_transport_runtime
  use fs_continuity_mod,                  only: W3, Wtheta
  use transport_enumerated_types_mod,     only: vertical_monotone_none,           &
                                                vertical_monotone_strict,         &
                                                vertical_monotone_relaxed,        &
                                                vertical_monotone_order_constant, &
                                                vertical_monotone_order_linear,   &
                                                vertical_monotone_order_high
  use geometric_constants_mod,            only: get_height
  use psykal_lite_mod,                    only: invoke_copy_to_rtran

  implicit none

  private

  public :: vertical_sl_advective_alg

contains

  !-----------------------------------------------------------------------------
  !> @brief An algorithm to interpolate data to departure points (SL-advection).
  !!
  !> @param[in,out]  field_np1          Field at timestep n+1 = field_n at departure point
  !> @param[in]      field_n            Field at timestep n
  !> @param[in]      transport_metadata Metadata for the advection of field
  subroutine vertical_sl_advective_alg( field_np1, field_n, transport_metadata )

    implicit none

    type(r_tran_field_type),       intent(inout) :: field_np1
    type(r_tran_field_type),       intent(in)    :: field_n
    type(transport_metadata_type), intent(in)    :: transport_metadata

    type(r_tran_field_type)          :: dep_pts_z
    type(r_tran_field_type), pointer :: dep_pts_z_get => null()
    type(field_type), pointer :: height_rdef => null()
    type(r_tran_field_type)   :: height
    type(mesh_type),  pointer :: mesh => null()
    type(transport_runtime_type), pointer :: transport_runtime => null()
    integer(kind=i_def)  :: monotone, monotone_order, sl_order
    logical(l_def)       :: reversibility
    logical(kind=l_def)  :: log_space

    if ( subroutine_timers ) call timer( 'vertical_sl_advective_alg' )

    if ( vertical_sl_order /= vertical_sl_order_cubic           .and. &
         vertical_sl_order /= vertical_sl_order_cubic_hermite   .and. &
         vertical_sl_order /= vertical_sl_order_quintic               ) then
      call log_event( "vertical_sl_advective: Invalid vertical_sl_order", LOG_LEVEL_ERROR )
    end if

    ! Get transport_runtime
    mesh => field_n%get_mesh()
    transport_runtime => get_transport_runtime(mesh)
    monotone = transport_metadata%get_vertical_monotone()
    monotone_order = transport_metadata%get_vertical_monotone_order()
    reversibility = transport_metadata%get_reversible()
    log_space  = transport_metadata%get_log_space()
    height_rdef => get_height( Wtheta, mesh%get_id() )
    call height%initialise( vector_space = height_rdef%get_function_space() )
    call invoke_copy_to_rtran( height, height_rdef )

    if ( monotone /= vertical_monotone_none    .and. &
         monotone /= vertical_monotone_strict  .and. &
         monotone /= vertical_monotone_relaxed       ) then
      call log_event( "vertical_sl_advective: Invalid monotone", LOG_LEVEL_ERROR )
    end if
    if ( monotone_order /= vertical_monotone_order_constant  .and. &
         monotone_order /= vertical_monotone_order_linear    .and. &
         monotone_order /= vertical_monotone_order_high            ) then
      call log_event( "vertical_sl_advective: Invalid monotone_order", LOG_LEVEL_ERROR )
    end if

    sl_order = vertical_sl_order
    if ( reversibility ) then
       sl_order = vertical_sl_order_cubic_hermite
    end if

    ! Get departure points from transport_runtime
    dep_pts_z_get  => transport_runtime%get_departure_points_z_w2( field_n%get_mesh_id() )
    call dep_pts_z%initialise( vector_space = dep_pts_z_get%get_function_space() )
    call invoke( setval_X(dep_pts_z, dep_pts_z_get) )

    ! If Strang splitting divide departure distance by 2
    if ( transport_metadata%get_splitting() ==  splitting_strang_vhv ) then
      call invoke( inc_a_times_X(0.5_r_tran, dep_pts_z) )
    end if

    ! Compute SL advective transport (vertical only) of
    ! field_np1 =  field_n_D
    call invoke( setval_X( field_np1, field_n ) )

    select case ( field_n%which_function_space() )
      case ( W3 )
        call invoke( vertical_sl_rho_kernel_type( dep_pts_z, field_np1, height,       &
                                                  sl_order, monotone, monotone_order, &
                                                  log_space ) )
      case ( Wtheta )
        call invoke( vertical_sl_theta_kernel_type( dep_pts_z, field_np1, height,       &
                                                    sl_order, monotone, monotone_order, &
                                                    log_space) )
      case default
        call log_event( "Vertical_sl_advective_alg only valid for W3 & Wtheta spaces", LOG_LEVEL_ERROR )
    end select

    ! End of step: if necessary enforce min val and overwrite in blending zone
    call end_of_advective_step_alg(field_np1, field_n, transport_metadata)

    nullify( dep_pts_z_get, mesh, transport_runtime, height_rdef )

    if ( subroutine_timers ) call timer( 'vertical_sl_advective_alg' )

  end subroutine vertical_sl_advective_alg

end module vertical_sl_advective_alg_mod
