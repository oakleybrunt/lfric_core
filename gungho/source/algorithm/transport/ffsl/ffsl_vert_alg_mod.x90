!-----------------------------------------------------------------------------
! (C) Crown copyright 2023 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Module for controlling 1D vertical FFSL steps.
!> @details Solves the 1D transport equation using the flux-form semi-Lagrangian
!!         (FFSL) transport scheme for vertical transport.
module ffsl_vert_alg_mod

  ! Constants and types
  use constants_mod,                    only: r_tran, i_def, l_def
  use fem_constants_mod,                only: get_inverse_w3_mass_matrix, &
                                              get_detj_at_w3_r_tran
  use field_mod,                        only: field_type
  use fs_continuity_mod,                only: W2V
  use function_space_mod,               only: function_space_type
  use function_space_collection_mod,    only: function_space_collection
  use geometric_constants_mod,          only: get_dz_w3
  use mesh_mod,                         only: mesh_type
  use operator_mod,                     only: operator_type
  use r_tran_field_mod,                 only: r_tran_field_type
  use timer_mod,                        only: timer
  use transport_enumerated_types_mod,   only: equation_form_advective,    &
                                              equation_form_conservative, &
                                              equation_form_consistent,   &
                                              splitting_strang_vhv,       &
                                              direction_v,                &
                                              vertical_monotone_none,     &
                                              vertical_monotone_strict,   &
                                              vertical_monotone_relaxed
  use transport_metadata_mod,           only: transport_metadata_type
  use transport_runtime_alg_mod,        only: transport_runtime_type
  use transport_runtime_collection_mod, only: get_transport_runtime

  ! Kernels
  use consist_vert_int_low_kernel_mod,  only: consist_vert_int_low_kernel_type
  use fv_divergence_z_kernel_mod,       only: fv_divergence_z_kernel_type
  use vert_int_low_kernel_mod,          only: vert_int_low_kernel_type
  use vert_nirvana_kernel_mod,          only: vert_nirvana_kernel_type
  use vert_nirvana_strict_kernel_mod,   only: vert_nirvana_strict_kernel_type
  use vert_nirvana_relax_kernel_mod,    only: vert_nirvana_relax_kernel_type
  use vert_nirvana_reversible_kernel_mod, &
                                        only: vert_nirvana_reversible_kernel_type
  use vert_nirvana_reversible_strict_kernel_mod, &
                                        only: vert_nirvana_reversible_strict_kernel_type
  use vert_nirvana_reversible_relax_kernel_mod, &
                                        only: vert_nirvana_reversible_relax_kernel_type
  use vert_ppm_limiter_kernel_mod,      only: vert_ppm_limiter_kernel_type
  use vert_ppm_no_limiter_kernel_mod,   only: vert_ppm_no_limiter_kernel_type
  use vert_ppm_strict_limiter_kernel_mod, &
                                        only: vert_ppm_strict_limiter_kernel_type

  ! Configuration options
  use io_config_mod,                    only: subroutine_timers
  use finite_element_config_mod,        only: element_order

  ! PSyKAl-lite code
  use psykal_lite_mod,                  only: invoke_copy_to_rtran

  implicit none

  private

  public :: ffsl_vert_transport_alg
  public :: ffsl_1d_vert_flux_alg

contains


  !> @brief Algorithm for a step of 1D vertical FFSL transport.
  !> @details Solves the 1D transport equation, in either advective or
  !!          conservative form. If needed, the mass flux or field increment
  !!          will be returned.
  !> @param[in,out] mass_flux          Mass flux used to transport the field.
  !> @param[in,out] increment          Increment for the field change over the
  !!                                   time step (per unit time). Only used when
  !!                                   specified through the optional argument
  !> @param[in,out] field_np1          The updated advected field from the time
  !!                                   step. Only used when specified through
  !!                                   the optional logical argument.
  !> @param[in]     field_n            Field at the start of the transport step
  !> @param[in]     step_dt            The dt for this time step
  !> @param[in]     transport_metadata Contains the configuration options for
  !!                                   transporting this field
  !> @param[in]     order              The reconstruction order to pass to
  !!                                   the underlying vertical flux algorithm
  !> @param[in]     compute_adv_inc    Optional argument as to whether advective
  !!                                   increment should be computed
  !> @param[in]     compute_field_np1  Optional argument as to whether advected
  !!                                   field should be computed
  subroutine ffsl_vert_transport_alg( mass_flux, increment,               &
                                      field_np1, field_n,                 &
                                      step_dt, transport_metadata, order, &
                                      compute_adv_inc, compute_field_np1 )

    implicit none

    ! Arguments ----------------------------------------------------------------
    type(r_tran_field_type),       intent(inout) :: mass_flux
    type(r_tran_field_type),       intent(inout) :: increment
    type(r_tran_field_type),       intent(inout) :: field_np1
    type(r_tran_field_type),       intent(in)    :: field_n
    real(kind=r_tran),             intent(in)    :: step_dt
    type(transport_metadata_type), intent(in)    :: transport_metadata
    integer(kind=i_def),           intent(in)    :: order
    logical(kind=l_def), optional, intent(in)    :: compute_adv_inc
    logical(kind=l_def), optional, intent(in)    :: compute_field_np1

    ! Internal variables -------------------------------------------------------
    ! Pointers to existing objects
    type(transport_runtime_type), pointer :: transport_runtime => null()
    type(mesh_type),              pointer :: mesh => null()
    type(r_tran_field_type),      pointer :: adv_one => null()
    type(operator_type),          pointer :: m3_inv => null()
    type(r_tran_field_type),      pointer :: rho_d_n => null()
    type(r_tran_field_type),      pointer :: rho_d_np1 => null()

    ! Function spaces
    type(function_space_type), pointer :: field_fs => null()

    ! Transport options
    logical(kind=l_def) :: to_compute_adv_inc
    logical(kind=l_def) :: to_compute_field_np1

    ! Subroutine name for timer
    character(*), parameter :: routine_name = 'ffsl_vert_transport_alg'

    type(r_tran_field_type) :: conservative_field_n
    type(r_tran_field_type) :: conservative_field_np1
    type(r_tran_field_type) :: divide_part
    type(r_tran_field_type) :: inc_part

    ! Useful constants
    integer(kind=i_def) :: mesh_id, step
    real(kind=r_tran)   :: one_over_dt

    if ( subroutine_timers ) call timer(routine_name)

    if (present(compute_adv_inc)) then
      to_compute_adv_inc = compute_adv_inc
    else
      to_compute_adv_inc = .true.
    end if

    if (present(compute_field_np1)) then
      to_compute_field_np1 = compute_field_np1
    else
      to_compute_field_np1 = .true.
    end if

    ! Vertical FFSL ------------------------------------------------------------
    call ffsl_1d_vert_flux_alg( mass_flux, field_n, step_dt, &
                                transport_metadata, order )

    ! Compute advected field, if required --------------------------------------
    if (to_compute_adv_inc .or. to_compute_field_np1) then
      ! Get pre-computed objects
      mesh_id = field_n%get_mesh_id()
      mesh => field_n%get_mesh()
      transport_runtime => get_transport_runtime(mesh)
      field_fs => field_n%get_function_space()
      m3_inv => get_inverse_w3_mass_matrix(mesh_id)

      step = transport_runtime%get_tracer_step_ctr()
      one_over_dt = 1.0_r_tran / step_dt

      call increment%initialise( vector_space = field_fs )
      call conservative_field_np1%initialise( vector_space = field_fs )

      select case ( transport_metadata%get_equation_form() )
      case ( equation_form_advective, equation_form_conservative )
        call inc_part%initialise( vector_space = field_fs )
        call divide_part%initialise( vector_space = field_fs )

        ! Get unity transport
        if ( transport_metadata%get_splitting() ==  splitting_strang_vhv ) then
          adv_one => transport_runtime%get_adv_unity_half_z(mesh_id)
        else
          adv_one => transport_runtime%get_adv_unity_z(mesh_id)
        end if

        call invoke( fv_divergence_z_kernel_type(increment, mass_flux,         &
                                                 m3_inv),                      &
                     X_minus_bY(conservative_field_np1, field_n,               &
                                step_dt, increment),                           &

        ! Get the advective increment from these conservative increments
        ! conservative_field_np1 = q - dt * F(q)
        ! adv_one   = 1 - dt * F(1)
        ! inc_part  = q - conservative_field_np1 / adv_one
        ! increment = inc_part / dt
                     X_divideby_Y(divide_part, conservative_field_np1,         &
                                  adv_one),                                    &
                     X_minus_Y(inc_part, field_n, divide_part) )

        if (to_compute_adv_inc) call invoke( a_times_X(increment, one_over_dt, inc_part) )
        if (to_compute_field_np1) call invoke( X_minus_Y(field_np1, field_n, inc_part) )

      case ( equation_form_consistent )
        call conservative_field_n%initialise( vector_space = field_fs )

        ! Multiply tracer mixing ratio by dry density to get tracer density
        rho_d_n => transport_runtime%get_rho_d(mesh_id, step)
        rho_d_np1 => transport_runtime%get_rho_d(mesh_id, step+1)

        call invoke( X_times_Y(conservative_field_n, field_n, rho_d_n),        &
                     ! Calculate increment to tracer density
                     fv_divergence_z_kernel_type(increment, mass_flux,         &
                                                 m3_inv),                      &
                     X_minus_bY(conservative_field_np1, conservative_field_n,  &
                                step_dt, increment),                           &
                     X_divideby_Y(field_np1, conservative_field_np1,           &
                                  rho_d_np1) )

        if (to_compute_adv_inc) then
          ! Increment is really a negative increment, so subtract field_np1
          call invoke( X_minus_Y(increment, field_n, field_np1),               &
                       inc_a_times_X(one_over_dt, increment) )
        end if
      end select
    end if

    nullify( mesh, transport_runtime, field_fs, adv_one, m3_inv )

    if ( subroutine_timers ) call timer(routine_name)

  end subroutine ffsl_vert_transport_alg

  !----------------------------------------------------------------------------
  !> @brief   Computes the mass flux associated with a vertical FFSL step.
  !> @details Performs a conservative flux calculation using vertical FFSL.
  !> @param[in,out] mass_flux          Mass flux used to transport the field.
  !> @param[in]     field_n            Field at the start of the transport step
  !> @param[in]     step_dt            The dt for this time step
  !> @param[in]     transport_metadata Contains the configuration options for
  !!                                   transporting this field
  !> @param[in]     order              The reconstruction order to use
  subroutine ffsl_1d_vert_flux_alg( mass_flux, field_n, step_dt, &
                                    transport_metadata, order )

    implicit none

    ! Arguments ----------------------------------------------------------------
    type(r_tran_field_type),       intent(inout) :: mass_flux
    type(r_tran_field_type),       intent(in)    :: field_n
    real(kind=r_tran),             intent(in)    :: step_dt
    type(transport_metadata_type), intent(in)    :: transport_metadata
    integer(kind=i_def),           intent(in)    :: order

    ! Internal variables -------------------------------------------------------
    ! Pointers to existing objects
    type(transport_runtime_type), pointer :: transport_runtime => null()
    type(mesh_type),              pointer :: mesh => null()
    type(r_tran_field_type),      pointer :: dep_pts_z => null()
    type(r_tran_field_type),      pointer :: frac_wind_or_flux => null()
    type(r_tran_field_type),      pointer :: detj_at_w2v => null()
    type(r_tran_field_type),      pointer :: detj_at_w3 => null()
    type(r_tran_field_type),      pointer :: rho_d => null()
    type(field_type),             pointer :: dz_w3_rdef => null()

    ! Function spaces
    type(function_space_type), pointer :: field_fs => null()
    type(function_space_type), pointer :: w2v_fs => null()

    ! Transport options
    logical(kind=l_def) :: log_space
    integer(kind=i_def) :: monotone
    logical(kind=l_def) :: reversible
    integer(kind=i_def) :: equation_form
    logical(kind=l_def) :: strang_vhv

    ! Internal fields
    type(r_tran_field_type) :: dz_w3
    type(r_tran_field_type) :: mass_flux_low
    type(r_tran_field_type) :: mass_flux_high
    type(r_tran_field_type) :: mass_flux_int

    ! Useful constants
    integer(kind=i_def) :: mesh_id
    integer(kind=i_def) :: step
    real(kind=r_tran)   :: one_over_dt

    ! Get pre-computed objects and set pointers --------------------------------
    mesh_id = field_n%get_mesh_id()
    mesh => field_n%get_mesh()
    transport_runtime => get_transport_runtime(mesh)

    ! Get pre-computed fields
    detj_at_w2v => transport_runtime%get_detj_at_w2_transport(mesh_id, direction_v)
    dz_w3_rdef => get_dz_w3(mesh_id)

    ! Function spaces
    field_fs => field_n%get_function_space()
    w2v_fs => function_space_collection%get_fs( mesh, element_order, W2V )

    ! Get options
    monotone = transport_metadata%get_vertical_monotone()
    log_space = transport_metadata%get_log_space()
    reversible = transport_metadata%get_reversible()
    equation_form = transport_metadata%get_equation_form()
    strang_vhv = ( transport_metadata%get_splitting() ==  splitting_strang_vhv )

    ! Initialise fields used by all splitting options --------------------------
    call mass_flux%initialise( vector_space = w2v_fs )
    call mass_flux_low%initialise( vector_space = w2v_fs )
    call mass_flux_high%initialise( vector_space = w2v_fs )
    call mass_flux_int%initialise( vector_space = w2v_fs )
    call dz_w3%initialise( vector_space = field_fs )

    if ( equation_form == equation_form_consistent ) then
      ! No need to take Strang into account for tracer departure points, as this
      ! should already be factored into the departure points
      step = transport_runtime%get_tracer_step_ctr()
      dep_pts_z => transport_runtime%get_tracer_dep_pts_z(mesh_id, step)
      frac_wind_or_flux => transport_runtime%get_dry_frac_flux_z(mesh_id, step)
      detj_at_w3 => get_detj_at_w3_r_tran(mesh_id)
      rho_d => transport_runtime%get_rho_d(mesh_id, step)

    else
      dep_pts_z => transport_runtime%get_departure_points_z_w2(mesh_id, strang_vhv)
      if ( strang_vhv ) then
        frac_wind_or_flux => transport_runtime%get_frac_wind_z_half(mesh_id)
      else
        frac_wind_or_flux => transport_runtime%get_frac_wind_z(mesh_id)
      end if
    end if

    ! Initialise variables
    call invoke( setval_c(mass_flux, 0.0_r_tran) )
    call invoke_copy_to_rtran(dz_w3, dz_w3_rdef)

    ! Compute low order and integer fluxes -------------------------------------
    select case( equation_form )
    case ( equation_form_conservative, equation_form_advective )
      call invoke( vert_int_low_kernel_type(mass_flux_low,     &
                                            mass_flux_int,     &
                                            frac_wind_or_flux, &
                                            dep_pts_z,         &
                                            detj_at_w2v,       &
                                            field_n,           &
                                            dz_w3,             &
                                            step_dt) )
    case ( equation_form_consistent )
      call invoke( consist_vert_int_low_kernel_type(mass_flux_low,     &
                                                    mass_flux_int,     &
                                                    frac_wind_or_flux, &
                                                    dep_pts_z,         &
                                                    detj_at_w3,        &
                                                    field_n,           &
                                                    rho_d,             &
                                                    step_dt) )
    end select

    ! Compute high order fractional flux ---------------------------------------
    if (order == 0) then
      ! Reuse low order flux
      call invoke( setval_X(mass_flux_high, mass_flux_low) )
    else if (order == 1) then
      if (reversible) then
        ! Reversible Nirvana reconstruction
        if ( monotone == vertical_monotone_none) then
          call invoke( vert_nirvana_reversible_kernel_type(mass_flux_high,     &
                                                           frac_wind_or_flux,  &
                                                           dep_pts_z, field_n, &
                                                           dz_w3, log_space) )
        else if ( monotone == vertical_monotone_strict ) then
          call invoke( vert_nirvana_reversible_strict_kernel_type(             &
                                                           mass_flux_high,     &
                                                           frac_wind_or_flux,  &
                                                           dep_pts_z, field_n, &
                                                           dz_w3, log_space) )
        else
          call invoke( vert_nirvana_reversible_relax_kernel_type(              &
                                                           mass_flux_high,     &
                                                           frac_wind_or_flux,  &
                                                           dep_pts_z, field_n, &
                                                           dz_w3, log_space) )
        end if
      else
        ! Standard Nirvana reconstruction
        if ( monotone == vertical_monotone_none) then
          call invoke( vert_nirvana_kernel_type(mass_flux_high,                &
                                                frac_wind_or_flux,             &
                                                dep_pts_z,                     &
                                                field_n, dz_w3) )
        else if ( monotone == vertical_monotone_strict ) then
          call invoke( vert_nirvana_strict_kernel_type(                        &
                                                mass_flux_high,                &
                                                frac_wind_or_flux,             &
                                                dep_pts_z,                     &
                                                field_n, dz_w3) )
        else
          call invoke( vert_nirvana_relax_kernel_type(                         &
                                                mass_flux_high,                &
                                                frac_wind_or_flux,             &
                                                dep_pts_z,                     &
                                                field_n, dz_w3) )
        end if
      end if
    else
      if ( monotone == vertical_monotone_none) then
          ! Unlimited PPM
          call invoke( vert_ppm_no_limiter_kernel_type(mass_flux_high,         &
                                                       frac_wind_or_flux,      &
                                                       dep_pts_z, field_n,     &
                                                       dz_w3, log_space) )
      else if ( monotone == vertical_monotone_strict ) then
          ! Strict monotone PPM
          call invoke( vert_ppm_strict_limiter_kernel_type(                    &
                                                       mass_flux_high,         &
                                                       frac_wind_or_flux,      &
                                                       dep_pts_z, field_n,     &
                                                       dz_w3, log_space) )
      else
          ! Relaxed monotone PPM
          call invoke( vert_ppm_limiter_kernel_type( mass_flux_high,           &
                                                     frac_wind_or_flux,        &
                                                     dep_pts_z, field_n,       &
                                                     dz_w3, log_space) )
      end if
    end if

    ! Correct for dimensions: the dry mass flux contains a factor of dt which
    ! needs dividing out. This is already taken care of for the low-order flux
    ! so only divide when reconstruction is higher order
    if ( equation_form == equation_form_consistent .and. order > 0 ) then
      one_over_dt = 1.0_r_tran / step_dt
      call invoke( inc_a_times_X(one_over_dt, mass_flux_high) )
    end if

    ! Combine integer and fractional fluxes
    call invoke( X_plus_Y(mass_flux, mass_flux_high, mass_flux_int) )

    nullify( dep_pts_z, detj_at_w2v, field_fs,  w2v_fs, dz_w3_rdef,            &
             frac_wind_or_flux, transport_runtime, mesh )

  end subroutine ffsl_1d_vert_flux_alg

end module ffsl_vert_alg_mod
