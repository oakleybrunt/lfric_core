!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

!>@brief Compute the locally assembled SI operators
module si_operators_alg_mod
  use constants_mod,             only: i_def, r_def
  use operator_mod,              only: operator_type
  use field_mod,                 only: field_type
  use fs_continuity_mod,         only: W2
  use log_mod,                   only: log_event,      &
                                       LOG_LEVEL_INFO, &
                                       LOG_LEVEL_ERROR
  use helmholtz_solver_config_mod, &
                                 only: preconditioner,                              &
                                       helmholtz_solver_preconditioner_tridiagonal, &
                                       normalise
  use output_config_mod,         only: subroutine_timers 
  use timer_mod,                 only: timer

  implicit none
  private

  ! Variables private to this module that can only be accessed by public
  ! functions returning pointers to them 
  type(operator_type), target :: m3_rho_star
  type(operator_type), target :: m3_exner_star
  type(operator_type), target :: div_star
  type(operator_type), target :: p2theta
  type(operator_type), target :: ptheta2
  type(operator_type), target :: ptheta2v
  type(operator_type), target :: p3theta
  type(operator_type), target :: compound_div
  type(field_type),    target :: rho_at_u
  type(field_type),    target :: tri_precon(3)
  type(field_type),    target :: Helm_diag
  type(field_type),    target :: Hb_lumped_inv

 ! Public functions to create and access the module contents
  public :: create_si_operators
  public :: compute_si_operators
  public :: final_si_operators
  public :: get_m3_rho_star
  public :: get_m3_exner_star 
  public :: get_div_star
  public :: get_p2theta
  public :: get_ptheta2 
  public :: get_ptheta2v
  public :: get_p3theta
  public :: get_compound_div 
  public :: get_rho_at_u 
  public :: get_tri_precon
  public :: get_helm_diag
  public :: get_Hb_lumped_inv

contains

  !>@brief Subroutine to create the si operators
  !>@param[in] mesh_id Identifier for the mesh
  subroutine create_si_operators(mesh_id)

    use function_space_mod,        only: function_space_type
    use fs_continuity_mod,         only: W0, W2, W3, Wtheta
    use finite_element_config_mod, only: element_order
    use function_space_collection_mod, &
                                   only: function_space_collection

    implicit none

    integer(i_def), intent(in) :: mesh_id

    type(function_space_type), pointer     :: w2_fs => null()
    type(function_space_type), pointer     :: w3_fs => null()
    type(function_space_type), pointer     :: wt_fs => null()

    if ( subroutine_timers ) call timer('si_operators_alg:create')
    call log_event( "Gungho: creating si_operators", LOG_LEVEL_INFO )

    w2_fs => function_space_collection%get_fs( mesh_id, element_order, W2 )
    w3_fs => function_space_collection%get_fs( mesh_id, element_order, W3 )
    wt_fs => function_space_collection%get_fs( mesh_id, element_order, Wtheta )
 
    m3_rho_star       = operator_type( w3_fs, w3_fs )
    m3_exner_star     = operator_type( w3_fs, w3_fs )
    div_star          = operator_type( w2_fs, w3_fs )
    p2theta           = operator_type( w2_fs, wt_fs )
    ptheta2           = operator_type( wt_fs, w2_fs )
    ptheta2v          = operator_type( wt_fs, w2_fs )
    p3theta           = operator_type( w3_fs, wt_fs )
    compound_div      = operator_type( w3_fs, w2_fs )

    rho_at_u  = field_type(vector_space = w2_fs)

    if ( preconditioner == helmholtz_solver_preconditioner_tridiagonal ) then
      if ( element_order /= 0 ) then
        call log_event( "tridiagonal precon only valid for order 0", &
                        LOG_LEVEL_ERROR )
      end if
      tri_precon(1) = field_type(vector_space = w3_fs)
      tri_precon(2) = field_type(vector_space = w3_fs)
      tri_precon(3) = field_type(vector_space = w3_fs)
    end if
    helm_diag     = field_type(vector_space = w3_fs)
    Hb_lumped_inv = field_type(vector_space = w2_fs)

    nullify( w2_fs, w3_fs, wt_fs )

    if ( subroutine_timers ) call timer('si_operators_alg:create')

  end subroutine create_si_operators

  !> @brief Explicitly reclaim memory from module scope variables
  subroutine final_si_operators()

    implicit none

    integer(i_def) :: i

    call m3_rho_star%operator_final()
    call m3_exner_star%operator_final()
    call div_star%operator_final()
    call p2theta%operator_final()
    call ptheta2%operator_final()
    call ptheta2v%operator_final()
    call p3theta%operator_final()
    call compound_div%operator_final()

    call rho_at_u%field_final()
    call Helm_diag%field_final()
    do i=1, size(tri_precon)
      call tri_precon(i)%field_final()
    end do
    call hb_lumped_inv%field_final()
  end subroutine final_si_operators

  !>@brief Subroutine to compute the si operators
  !>@param[in] ref_state Bundle of reference states used to create linear operators
  subroutine compute_si_operators(ref_state)
    use quadrature_xyoz_mod,             only: quadrature_xyoz_type
    use quadrature_face_mod,             only: quadrature_face_type
    use quadrature_rule_gaussian_mod,    only: quadrature_rule_gaussian_type
    use eos_operators_kernel_mod,        only: eos_operators_kernel_type
    use weighted_div_kernel_mod,         only: weighted_div_kernel_type
    use weighted_proj_2theta_kernel_mod, only: weighted_proj_2theta_kernel_type
    use weighted_proj_theta2_kernel_mod, only: weighted_proj_theta2_kernel_type
    use weighted_proj_theta2_vert_kernel_mod, &
                                         only: weighted_proj_theta2_vert_kernel_type
    use compound_operator_kernel_mod,    only: compound_operator_kernel_type
    use compute_tri_precon_kernel_mod,   only: compute_tri_precon_kernel_type
    use sample_flux_kernel_mod,          only: sample_flux_kernel_type
    use psykal_lite_mod,                 only: invoke_weighted_div_bd_kernel_type,         &
                                               invoke_weighted_div_bd_kernel_type,         &
                                               invoke_weighted_proj_2theta_bd_kernel_type, &
                                               invoke_weighted_proj_theta2_bd_kernel_type
    use finite_element_config_mod,       only: element_order
    use function_space_mod,              only: function_space_type
    use runtime_constants_mod,           only: get_coordinates, &
                                               get_div, &
                                               get_mass_matrix, &
                                               w2_id, w3inv_id, wt_id, dl_id, &
                                               get_rmultiplicity, &
                                               get_normalisation
    use derived_config_mod,              only: bundle_size
    use invert_local_operator_kernel_mod,only: invert_local_operator_kernel_type
    use field_indices_mod,               only: igh_u, igh_t, igh_d, igh_p
    use planet_config_mod,               only: kappa, cp
    use timestepping_config_mod,         only: tau_r, tau_t, tau_u, dt
    use reference_element_mod,           only: reference_element_type
    use mesh_mod,                        only: mesh_type
    use matrix_vector_kernel_mod,        only: matrix_vector_kernel_type
    use formulation_config_mod,          only: dlayer_on

    implicit none

    type(field_type), target, intent(in)   :: ref_state(bundle_size) ! (u, theta, rho, exner)
    type(field_type),            pointer   :: theta => null(), &
                                              rho => null(), &
                                              exner => null()
    type(quadrature_xyoz_type)             :: qr
    type(quadrature_face_type)             :: qrf
    type(quadrature_rule_gaussian_type)    :: quadrature_rule
    type(field_type),              pointer :: chi(:) => null()
    type(operator_type),           pointer :: m3_inv => null(), div => null()
    type(field_type)                       :: ones
    type(field_type),              pointer :: w2_rmultiplicity => null()
    type(function_space_type),     pointer :: u_fs => null()
    real(r_def)                            :: const1, const2
    integer(i_def), parameter              :: imone = -1_i_def
    real(r_def), parameter                 :: one   = 1_i_def
    class(reference_element_type), pointer :: reference_element =>null()
    type(mesh_type),               pointer :: mesh => null()
    type(operator_type),           pointer :: m2 => null()
    type(field_type),              pointer :: u_normalisation => null(), &
                                              t_normalisation => null() 
    type(field_type)                       :: m2_u, theta_adv_term

    if ( subroutine_timers ) call timer('si_operators_alg:compute')
    call log_event( "Gungho: computing si_operators", LOG_LEVEL_INFO )

    theta  => ref_state(igh_t)
    rho    => ref_state(igh_d)
    exner  => ref_state(igh_p)
    chi    => get_coordinates()

    ! Operators for the equation of state
    qr = quadrature_xyoz_type(element_order+3, quadrature_rule)
    const1 = (1.0_r_def-kappa)/kappa
    call invoke( eos_operators_kernel_type(m3_exner_star, m3_rho_star, p3theta, &
                                          exner, rho, theta, chi, const1, qr) )

    ! The rest of the operators are topological and so do not need as high
    ! quadrature order
    qr = quadrature_xyoz_type(element_order+2, quadrature_rule)
    mesh => theta%get_mesh()
    reference_element => mesh%get_reference_element()
    qrf = quadrature_face_type(element_order+2, .true., .false., &
                               reference_element, quadrature_rule)
    ! Cell kernels
    const1 = tau_u*dt*cp
    const2 = tau_t*dt
    call invoke( weighted_div_kernel_type(div_star, theta, const1, qr),         &
                 weighted_proj_2theta_kernel_type(p2theta, exner, const1, qr),  & 
                 weighted_proj_theta2_vert_kernel_type(ptheta2v, theta, const2, &
                                                      qr),                      &
                 weighted_proj_theta2_kernel_type(ptheta2, theta, const2, qr) )

    ! Boundary kernels
    call invoke_weighted_div_bd_kernel_type(div_star, theta, const1, qrf)
    call invoke_weighted_proj_theta2_bd_kernel_type(ptheta2, theta, const2, qrf)
    call invoke_weighted_proj_2theta_bd_kernel_type(p2theta, exner, const1, qrf)

    ! Compute rho^ref at u nodal points
    u_fs => ref_state(igh_u)%get_function_space()
    ones = field_type( vector_space = u_fs )

    w2_rmultiplicity => get_rmultiplicity( W2 )
    ! Initialise fields
    call invoke( setval_c(ones,     1.0_r_def),                 &
                 setval_c(rho_at_u, 0.0_r_def),                 &
                 sample_flux_kernel_type(rho_at_u, ones,        &
                                         w2_rmultiplicity, rho) )

    const1 = tau_r*dt
    m3_inv => get_mass_matrix(w3inv_id)
    div    => get_div()
    call invoke( compound_operator_kernel_type(compound_div, m3_rho_star, m3_inv, div, &
                                               rho_at_u, const1) )
    ! Compute Hb_lumped_inv field
    if (dlayer_on) then
      m2 => get_mass_matrix(dl_id)
    else
      m2 => get_mass_matrix(w2_id)
    end if
    u_normalisation => get_normalisation(w2_id)
    t_normalisation => get_normalisation(wt_id)
    
    m2_u           = field_type( vector_space = u_fs )
    ones           = field_type( vector_space = u_fs )
    theta_adv_term = field_type( vector_space = theta%get_function_space() )
    call invoke( name = "Compute lumped inverse H_B operator",               &
                 setval_c(ones, 1.0_r_def),                                  &
                 setval_c(Hb_lumped_inv, 0.0_r_def),                         &
                 setval_c(m2_u, 0.0_r_def),                                  &
                 setval_c(theta_adv_term, 0.0_r_def),                        &
                 matrix_vector_kernel_type(m2_u, ones, m2),                  &
                 matrix_vector_kernel_type(theta_adv_term, ones, ptheta2v),  &
                 inc_X_times_Y(theta_adv_term, t_normalisation),             &
                 matrix_vector_kernel_type(Hb_lumped_inv, theta_adv_term,    &
                                           p2theta),                         & 
                 inc_aX_plus_Y(one, Hb_lumped_inv, m2_u),                    &
                 inc_X_times_Y(Hb_lumped_inv, u_normalisation),              &
                 inc_X_powint_n(Hb_lumped_inv, imone) )

    ! Compute terms for tridiagonal preconditioner
    if ( preconditioner == helmholtz_solver_preconditioner_tridiagonal ) then
      call invoke( compute_tri_precon_kernel_type(tri_precon, theta, rho, exner, chi) )
    end if
    if ( normalise ) then
      if ( preconditioner == helmholtz_solver_preconditioner_tridiagonal) then
        Helm_diag = tri_precon(1)
        ! PSyclone does not currently support raising field to an integer power
        call invoke( name = "Normalise tridiagonal preconditioner", &
                     inc_X_powint_n(Helm_diag, imone),              &
                     inc_X_times_Y(tri_precon(1), Helm_diag),       &
                     inc_X_times_Y(tri_precon(2), Helm_diag),       &
                     inc_X_times_Y(tri_precon(3), Helm_diag) )
      else
        call invoke( setval_c(Helm_diag, 1.0_r_def) )
      end if
    else
      call invoke( setval_c(Helm_diag, 1.0_r_def) )
    end if

    nullify( theta, rho, exner, chi, m3_inv, div, w2_rmultiplicity, &
             mesh, reference_element, m2, u_normalisation, t_normalisation, &
             u_fs )

    if ( subroutine_timers ) call timer('si_operators_alg:compute')

  end subroutine compute_si_operators

 !> @brief Function to return a pointer to the m3_rho_star
 !> @return The operator
  function get_m3_rho_star() result(op)
    implicit none
    type(operator_type), pointer ::op
    op => m3_rho_star
  end function get_m3_rho_star

 !> @brief Function to return a pointer to the m3_exner_star
 !> @return The operator
  function get_m3_exner_star() result(op)
    implicit none
    type(operator_type), pointer ::op
    op => m3_exner_star
  end function get_m3_exner_star

 !> @brief Function to return a pointer to the div_star
 !> @return The operator
  function get_div_star() result(op)
    implicit none
    type(operator_type), pointer ::op
    op => div_star
  end function get_div_star

 !> @brief Function to return a pointer to the p2theta
 !> @return The operator
  function get_p2theta() result(op)
    implicit none
    type(operator_type), pointer ::op
    op => p2theta
  end function get_p2theta

 !> @brief Function to return a pointer to the ptheta2
 !> @return The operator
  function get_ptheta2() result(op)
    implicit none
    type(operator_type), pointer ::op
    op => ptheta2
  end function get_ptheta2

 !> @brief Function to return a pointer to the ptheta2v
 !> @return The operator
  function get_ptheta2v() result(op)
    implicit none
    type(operator_type), pointer ::op
    op => ptheta2v
  end function get_ptheta2v

 !> @brief Function to return a pointer to the p3theta
 !> @return The operator
  function get_p3theta() result(op)
    implicit none
    type(operator_type), pointer ::op
    op => p3theta
  end function get_p3theta

 !> @brief Function to return a pointer to the compound div
 !> @return The operator
  function get_compound_div() result(op)
    implicit none
    type(operator_type), pointer ::op
    op => compound_div
  end function get_compound_div

 !> @brief Function to return a pointer to the rho_at_u
 !> @return The field
  function get_rho_at_u() result(field)
    implicit none
    type(field_type), pointer :: field
    field => rho_at_u
  end function get_rho_at_u

 !> @brief Function to return a pointer to the tri_precon
 !> @return The field
  function get_tri_precon() result(field)
    implicit none
    type(field_type), pointer :: field(:)
    field => tri_precon
  end function get_tri_precon

 !> @brief Function to return a pointer to the Helm diagonal
 !> @return The field
  function get_helm_diag() result(field)
    implicit none
    type(field_type), pointer :: field
    field => helm_diag
  end function get_helm_diag

 !> @brief Function to return a pointer to the lumped inverse Hb operator
 !> @return The field
  function get_hb_lumped_inv() result(field)
    implicit none
    type(field_type), pointer :: field
    field => hb_lumped_inv
  end function get_hb_lumped_inv

end module si_operators_alg_mod
