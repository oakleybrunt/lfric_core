!-----------------------------------------------------------------------------
! (c) Crown copyright 2019 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> Test the scale by detJ kernel
module scale_by_detj_kernel_mod_test

  use constants_mod, only : i_def, r_def
  use pFUnit_Mod

  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(TestCase), public :: scale_by_detj_test_type
    private
  contains
    procedure test_all
  end type scale_by_detj_test_type

contains

  @test
  subroutine test_all( this )

    use scale_by_detj_kernel_mod, only : scale_by_detj_code

    implicit none

    class(scale_by_detj_test_type), intent(inout) :: this

    real(kind=r_def), parameter :: tol = 1.0e-9_r_def

    ! Mesh
    integer(kind=i_def), parameter :: nlayers = 2

    ! Scalar Space
    integer(kind=i_def), parameter          :: ndf_ws = 2_i_def
    integer(kind=i_def), parameter          :: undf_ws = nlayers + 1_i_def
    integer(kind=i_def), dimension(ndf_ws)  :: map_ws
    real(kind=r_def),    dimension(undf_ws) :: field
    ! Coordinate Space
    integer(kind=i_def), parameter          :: ndf_wx  = 8_i_def
    integer(kind=i_def), parameter          :: undf_wx = ndf_wx*nlayers
    integer(kind=i_def), dimension(ndf_wx)  :: map_wx
    real(kind=r_def),    dimension(undf_wx) :: x, y, z

    real(kind=r_def),    dimension(3,ndf_wx,ndf_ws) :: diff_basis_wx

    real(kind=r_def), parameter              :: dx = 10.0_r_def
    real(kind=r_def), parameter              :: dy = 5.0_r_def
    real(kind=r_def), dimension(0:nlayers)   :: r
    real(kind=r_def), dimension(0:nlayers-1) :: vol

    integer(kind=r_def)                   :: k, df, d
    real(kind=r_def), dimension(ndf_ws,3) :: nodes
    real(kind=r_def), dimension(3)        :: f1, f2
    real(kind=r_def), dimension(undf_ws)  :: answer

    map_ws = (/ 1, 2 /)
    map_wx(1) = 1
    do df = 2,ndf_wx
      map_wx(df) = map_wx(df-1) + nlayers
    end do
    ! Set variable vertical resolution
    r(0) = 0.0_r_def
    do k = 1,nlayers
      r(k) = r(k-1) + real(k,r_def)
    end do

    ! Compute the coordinate fields
    x = 0.0_r_def
    y = 0.0_r_def
    z = 0.0_r_def
    do k = 0,nlayers-1
      x(map_wx(2)+k) = dx
      x(map_wx(4)+k) = dx
      x(map_wx(6)+k) = dx
      x(map_wx(8)+k) = dx
      y(map_wx(3)+k) = dy
      y(map_wx(4)+k) = dy
      y(map_wx(7)+k) = dy
      y(map_wx(8)+k) = dy
      do df = 1,4
        z(map_wx(df)+k)   = r(k)
        z(map_wx(df+4)+k) = r(k+1)
      end do
      vol(k) = dx*dy*(r(k+1)-r(k))
    end do

    ! Assume ws is wtheta, i.e. nodal points are in the centre of the top and
    ! bottom faces: (x,y,z) = (0.5,0.5,0.0), (0.5,0.5,1.0)
    nodes(:,1) = 0.5_r_def
    nodes(:,2) = 0.5_r_def
    nodes(1,3) = 0.0_r_def
    nodes(2,3) = 1.0_r_def
    do df = 1,ndf_ws
      do d = 1,3
        f1(d) = 1.0_r_def - nodes(df,d)
        f2(d) = nodes(df,d)
      end do
      diff_basis_wx(1,1,df) = -f1(2)*f1(3)
      diff_basis_wx(2,1,df) = -f1(1)*f1(3)
      diff_basis_wx(3,1,df) = -f1(1)*f1(2)

      diff_basis_wx(1,2,df) =  f1(2)*f1(3)
      diff_basis_wx(2,2,df) = -f2(1)*f1(3)
      diff_basis_wx(3,2,df) = -f2(1)*f1(2)

      diff_basis_wx(1,3,df) = -f2(2)*f1(3)
      diff_basis_wx(2,3,df) =  f1(1)*f1(3)
      diff_basis_wx(3,3,df) = -f1(1)*f2(2)

      diff_basis_wx(1,4,df) =  f2(2)*f1(3)
      diff_basis_wx(2,4,df) =  f2(1)*f1(3)
      diff_basis_wx(3,4,df) = -f2(1)*f2(2)

      diff_basis_wx(1,5,df) = -f1(2)*f2(3)
      diff_basis_wx(2,5,df) = -f1(1)*f2(3)
      diff_basis_wx(3,5,df) =  f1(1)*f1(2)

      diff_basis_wx(1,6,df) =  f1(2)*f2(3)
      diff_basis_wx(2,6,df) = -f2(1)*f2(3)
      diff_basis_wx(3,6,df) =  f2(1)*f1(2)

      diff_basis_wx(1,7,df) = -f2(2)*f2(3)
      diff_basis_wx(2,7,df) =  f1(1)*f2(3)
      diff_basis_wx(3,7,df) =  f1(1)*f2(2)

      diff_basis_wx(1,8,df) =  f2(2)*f2(3)
      diff_basis_wx(2,8,df) =  f2(1)*f2(3)
      diff_basis_wx(3,8,df) =  f2(1)*f2(2)
    end do

    ! Set some values for the initial field
    do df = 1, undf_ws
      field(df) = real(df,r_def)
    end do

    answer(1) = field(1)/vol(0)
    do k = 1,nlayers-1
      answer(k+1) = 2.0_r_def*field(k+1)/(vol(k-1)+vol(k))
    end do
    answer(nlayers+1) = field(nlayers+1)/vol(nlayers-1)

    call scale_by_detj_code(nlayers,                 &
                            field,                   &
                            x, y, z,                 &
                            ndf_ws, undf_ws, map_ws, &
                            ndf_wx, undf_wx, map_wx, &
                            diff_basis_wx            &
                            )

    @assertEqual(answer,field, tol)

  end subroutine test_all

end module scale_by_detj_kernel_mod_test
